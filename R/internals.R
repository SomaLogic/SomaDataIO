# Internal functions to SomaDataIO
# Generated by data-raw/create_internals.R
# Do not edit by hand ...
# -----------------------

addAttributes <- function (data, new.atts) 
{
    if (is.null(dim(data))) {
        usethis::ui_warn("Subsetting changed the shape of the object. \\\n      Should be a `data.frame` but is class `{class(data)}`.")
    }
    stopifnot(inherits(new.atts, "list"))
    attrs <- setdiff(names(new.atts), names(attributes(data)))
    for (i in attrs) {
        attributes(data)[[i]] <- new.atts[[i]]
    }
    return(data)
}
addClass <- function (x, class) 
{
    new_class <- c(class, class(x)) %>% unique()
    structure(x, class = new_class)
}
genRowNames <- function (adat) 
{
    checkDups <- function(x) any(duplicated(x))
    if (all(c("Subarray", "SlideId") %in% names(adat))) {
        adat_rn <- paste0(adat$SlideId, "_", adat$Subarray)
        if (checkDups(adat_rn)) {
            if ("PlateId" %in% names(adat)) {
                adat_rn <- paste0(adat$PlateId, "_", adat_rn)
            }
            else if ("DatasetId" %in% names(adat)) {
                adat_rn <- paste0(adat$DatasetId, "_", adat_rn)
            }
            if (checkDups(adat_rn)) {
                usethis::ui_warn("Found duplicate row names, i.e. `SlideId_Subarray` non-unique. \\\n          They will be numbered sequentially.")
                adat_rn <- 1:nrow(adat)
            }
        }
    }
    else {
        usethis::ui_warn("No SlideId_Subarray found in ADAT. \\\n      Rows numbered sequentially.")
        adat_rn <- as.character(1:nrow(adat))
    }
    adat_rn
}
catchRunawayTabs <- function (x) 
{
    if (grepl("^\\^.*[\t]{250,}$", x)) {
        message("* Possible runaway tabs!")
        usethis::ui_stop("Invalid ADAT! Empty tabs filling out the entire header block.")
    }
}
cleanNames <- function (x) 
{
    stringr::str_trim(x) %>% stringr::str_replace_all("[^A-Za-z0-9]", 
        ".") %>% stringr::str_replace_all("\\.{2,}", ".") %>% 
        stringr::str_remove_all("^\\.|\\.$") %>% stringr::str_replace_all("^Hyb[.]Scale", 
        "HybControlNormScale") %>% stringr::str_replace_all("^Med[.]Scale", 
        "NormScale")
}
convertColMeta <- function (x) 
{
    tbl <- tibble::as_tibble(x) %>% purrr::set_names(cleanNames)
    if ("Dilution" %in% names(tbl)) {
        tbl <- tbl %>% dplyr::mutate(Dilution2 = stringr::str_remove_all(Dilution, 
            "%$|Mix ") %>% as.numeric()/100)
    }
    safe_num <- purrr::quietly(as.numeric)
    convert_num <- function(.x) {
        y <- safe_num(.x)$warnings
        lgl <- !isTRUE(y == "NAs introduced by coercion")
        lgl && !inherits(.x, c("factor", "integer"))
    }
    tbl %>% purrr::modify_if(convert_num, as.numeric) %>% dplyr::mutate(Dilution = as.character(Dilution), 
        SeqId = getSeqId(SeqId, TRUE))
}
checkADAT <- function (adat) 
{
    atts <- attributes(adat)
    apts <- get_features(names(adat))
    meta <- setdiff(names(adat), apts)
    if (!isTRUE(all.equal(cleanNames(meta), cleanNames(atts$Header.Meta$ROW_DATA$Name)))) {
        usethis::ui_stop("Meta data mismatch between `Header Meta` and ADAT meta data. \\\n      Check `attributes(ADAT)$Header.Meta$ROW_DATA$Name`.")
    }
    if (length(apts) != nrow(as.data.frame(atts$Col.Meta))) {
        usethis::ui_stop("Number of aptamers in ADAT does not match No. aptamers in Col.Meta!")
    }
    if (nrow(adat) == 0) {
        usethis::ui_warn("ADAT has no rows! Writing just header and column meta data")
    }
    usethis::ui_done("ADAT passed checks and traps")
    invisible(NULL)
}
.diffAdatColumns <- function (x, y, meta = FALSE, tolerance) 
{
    type <- ifelse(meta, "Meta", "Feature")
    .fun <- switch(type, Meta = .getmeta, Feature = .getfeat)
    cols <- intersect(.fun(x), .fun(y))
    test_lgl <- purrr::map2_lgl(x[, cols], y[, cols], ~{
        if (meta) {
            assertthat::are_equal(as.character(.x), as.character(.y), 
                check.names = FALSE)
        }
        else {
            assertthat::are_equal(.x, .y, tolerance = tolerance)
        }
    })
    msg <- stringr::str_pad(sprintf("All %s data is identical", 
        type), 35, "right")
    if (all(test_lgl, na.rm = TRUE)) {
        usethis::ui_todo("{msg} {crayon::green(cli::symbol$tick)}")
        invisible(NULL)
    }
    else {
        usethis::ui_todo("{msg} {crayon::red(cli::symbol$cross)}")
        vec <- purrr::keep(test_lgl, !test_lgl) %>% names()
        stringr::str_pad("    No. fields that differ ", 37, "right") %>% 
            paste(length(vec)) %>% writeLines()
        cli::rule(sprintf("%s data diffs", type), line_col = crayon::magenta) %>% 
            writeLines()
        print(usethis::ui_value(vec))
        invisible(NULL)
    }
}
regexSeqId <- function () 
{
    "[0-9]{4,5}[-.][0-9]{1,3}([._][0-9]{1,3})?$|^SL[0-9]{6}$"
}
getSeqId <- function (x, trim.version = FALSE) 
{
    x <- stringr::str_trim(x)
    match_mat <- stringr::str_locate(x, regexSeqId())
    args <- list(string = x, start = match_mat[, "start"], end = match_mat[, 
        "end"])
    seqId <- purrr::pmap_chr(args, stringr::str_sub) %>% stringr::str_replace("\\.", 
        "-") %>% stringr::str_replace("\\.", "_")
    if (trim.version) {
        stringr::str_split(seqId, "_") %>% purrr::map_chr(1L)
    }
    else {
        seqId
    }
}
get_features <- function (x) 
{
    if (inherits(x, c("soma_adat", "data.frame"))) {
        usethis::ui_stop("You've passed a `data.frame` to `get_features()` ... \\\n      you must pass `names(df)` instead.")
    }
    assertthat::assert_that(is.null(dim(x)))
    x[is.seq(x)]
}
getAdatVersion <- function (x) 
{
    vidx <- grep("^Version$|^AdatVersion$", names(x$HEADER))
    if (length(vidx) == 0) {
        usethis::ui_stop("Unable to identify ADAT Version from Header information. \\\n      Please check 'Header.Meta'.")
    }
    version <- x$HEADER[[vidx]]
    if (length(version) > 1) {
        usethis::ui_warn("Version length > 1 ... there may be empty tabs in \\\n      the header block filling out the data matrix.")
        version <- version[1L]
    }
    if (version == "1.01") {
        usethis::ui_stop("Fix java ADAT writer! Version cannot be `1.01` (set = 1.0.1)")
    }
    return(version)
}
parseCheck <- function (all.tokens, verbose = TRUE) 
{
    if (inherits(all.tokens, "character") && length(all.tokens) == 
        1) {
        usethis::ui_stop("Format is wrong for the `all.tokens` argument. \\\n      Are you sure you are passing a list of TOKENS and *not* a filename?")
    }
    firsts <- purrr::map_chr(all.tokens, head, n = 1)
    chk_string <- c("^HEADER", "^ROW_DATA", "^COL_DATA", "^TABLE_BEGIN")
    if (any(!chk_string %in% firsts)) {
        usethis::ui_stop(stringr::str_glue("The following *landmark* tokens is absent from \\\n        the ADAT header: {ui_value(df)}", 
            df = paste(setdiff(chk_string, firsts), collapse = ", ")))
    }
    tab_test <- all.tokens[[which(firsts == "^HEADER")]]
    if (length(tab_test) > 100) {
        writeLines(cli::rule(crayon::bold("Head"), line_col = crayon::blue))
        print(utils::head(tab_test, 10))
        writeLines(cli::rule(crayon::bold("Tail"), line_col = crayon::blue))
        print(utils::tail(tab_test, 10))
        cat("\n")
        message(stringr::str_glue("This does not appear to be a valid ADAT\n        One possibility is that there are empty tabs filling out the entire header block\n        Are there empty strings indicated above?"))
        cat("\n")
    }
    table_begin <- which(firsts == "^TABLE_BEGIN")
    which_col_meta_start <- table_begin + 1
    col_meta_shift <- grep("[A-Za-z0-9]", all.tokens[[which_col_meta_start]])[1]
    row_meta <- all.tokens[[which(firsts == "^ROW_DATA") + 1]]
    col_meta <- all.tokens[[which(firsts == "^COL_DATA") + 1]]
    col_meta <- grep(".", col_meta, value = TRUE)[-1]
    row_meta <- grep(".", row_meta, value = TRUE)[-1]
    if (col_meta_shift != length(row_meta) + 1) {
        usethis::ui_stop("The Col.Meta shift `{col_meta_shift}` does not match the \\\n      length stated in ^ROW_DATA row `{length(row_meta) + 1}` -- \\\n      visually inspect ADAT")
    }
    which_col_meta_rows <- seq(which_col_meta_start, which_col_meta_start + 
        length(col_meta) - 1, 1)
    which_header_row <- table_begin + length(col_meta) + 1
    if (verbose) {
        writeLines(cli::rule(crayon::bold("Parsing Diagnostics"), 
            line_col = crayon::blue))
        c1 <- c("*  Table Begin", "*  Col.Meta Start", "*  Col.Meta Shift", 
            "*  Header Row", "*  Rows of the Col Meta") %>% format()
        c2 <- c(table_begin, which_col_meta_start, col_meta_shift, 
            which_header_row, Reduce(paste, which_col_meta_rows))
        paste0(c1, stringr::str_dup(" ", 4), crayon::green(cli::symbol$pointer), 
            "  ", c2) %>% writeLines()
        spaces <- stringr::str_dup(" ", 3)
        writeLines(cli::rule(crayon::bold("Col Meta"), line_col = crayon::blue, 
            right = stringr::str_glue("{length(col_meta)}")))
        col_print <- col_meta
        L <- length(col_meta)
        if (L%%4 != 0) {
            col_print <- c(col_meta, rep("", 4 - L%%4))
        }
        col_print %<>% format()
        col_print %<>% split(rep(1:4, each = length(.)/4))
        spaces <- stringr::str_dup(" ", 2)
        paste0(spaces, col_print[[1L]], spaces, crayon::cyan(" | "), 
            spaces, col_print[[2L]], spaces, crayon::cyan(" | "), 
            spaces, col_print[[3L]], spaces, crayon::cyan(" | "), 
            spaces, col_print[[4L]]) %>% writeLines()
        writeLines(cli::rule(crayon::bold("Row Meta"), line_col = crayon::blue, 
            right = stringr::str_glue("{length(row_meta)}")))
        row_print <- row_meta
        L <- length(row_meta)
        if (L%%4 != 0) {
            row_print %<>% c(rep("", 4 - L%%4))
        }
        row_print %<>% format()
        row_print %<>% split(rep(1:4, each = length(.)/4))
        paste0(spaces, row_print[[1L]], spaces, crayon::cyan(" | "), 
            spaces, row_print[[2L]], spaces, crayon::cyan(" | "), 
            spaces, row_print[[3L]], spaces, crayon::cyan(" | "), 
            spaces, row_print[[4L]]) %>% writeLines()
    }
    if (which_header_row >= length(all.tokens)) {
        message("No feature/RFU data ... Col.Meta only ADAT")
        writeLines(cli::rule("Done", line = 2, line_col = crayon::green))
        return()
    }
    col_meta2 <- purrr::map_chr(all.tokens[which_col_meta_start:(which_header_row - 
        1)], function(.x) .x[col_meta_shift])
    if (any(duplicated(col_meta2))) {
        writeLines(cli::rule(crayon::bold("Duplicated Col.Meta names"), 
            line_col = crayon::blue, right = crayon::red("!")))
        message("Duplicated Col.Meta names in col meta block")
        writeLines(stringr::str_glue("Potential over-write scenario for entry: \\\n        {paste(col_meta2[duplicated(col_meta2)], collapse = ', '}"))
    }
    if (!setequal(col_meta, col_meta2)) {
        message("*  Mismatch between `^COL_DATA` in header and `Col.Meta` block:")
        message(stringr::str_glue("*  In Header  : {col_meta}"))
        message(stringr::str_glue("*  In Col.Meta: {col_meta2}"))
        usethis::ui_stop("Stopping check early.")
    }
    string_in_table <- stringr::str_subset(all.tokens[[which_header_row]], 
        "[:alnum:]")
    if (!isTRUE(all.equal(sort(row_meta), sort(string_in_table)))) {
        cat(purrr::walk(1:length(row_meta), function(.x) sprintf(" %s -- %s\n", 
            row_meta[.x], string_in_table[.x])))
        usethis::ui_stop("Meta data mismatch between `Header Meta` vs `meta data` \\\n      in table ... ADAT line: {which_header_row}\n")
    }
    token_lengths <- purrr::map_dbl(all.tokens[-which_header_row], 
        length)
    data_lengths <- token_lengths[which_col_meta_start:length(token_lengths)]
    if (!all(data_lengths == data_lengths[1])) {
        writeLines(cli::rule(crayon::bold("Possible Tabs Problem"), 
            line_col = crayon::blue, right = crayon::red("!")))
        message("All Token lengths:")
        print(token_lengths)
        message("Data Block Token lengths:")
        print(data_lengths)
        tab <- table(data_lengths)
        names(dimnames(tab)) <- "Table of Lengths:"
        print(tab)
        usethis::ui_warn("* Token length is inconsistent for data matrix block\n      Check for trailing/missing tabs in the main block of the Adat\n      One (or more) of the above is different from the rest.")
    }
    table_width <- length(all.tokens[[which_header_row + 1]])
    header_length <- length(all.tokens[[which_header_row]])
    if ((table_width - header_length) > 10) {
        writeLines(cli::rule(crayon::bold("Problem with tabs in Header (blank) row"), 
            line_col = crayon::blue, right = crayon::red("!")))
        c1 <- c("*  Should be", "*  Currently is") %>% format()
        paste0(c1, stringr::str_dup(" ", 5), crayon::green(cli::symbol$pointer), 
            "  ", c(table_width, header_length)) %>% writeLines()
        message(stringr::str_glue("* Length of the header row is incorrect\n        * Does not match the width of the data table\n        * Likely a tabs problem"))
    }
    string_gaps <- !purrr::map_lgl(all.tokens[which_col_meta_rows], 
        function(.x) all(grepl(".", .x[col_meta_shift:length(.x)])))
    if (any(string_gaps)) {
        writeLines(cli::rule(crayon::bold("Empty Strings Detected in Col.Meta"), 
            line_col = crayon::blue, right = crayon::red("!")))
        message(stringr::str_glue("Visually inspect the following Col.Meta rows:\n {rr}", 
            rr = paste0(col_meta2[string_gaps], collapse = "\n  ")))
        message(stringr::str_glue("They may be missing in:\n        -  Spuriomers\n        -  HybControls\n        Strings may be missing in SOMAmers \\\n        without a EntrezGeneSymbol (e.g. a family)\n        This is a non-critical bug ..."))
    }
    cat("\n")
    writeLines(cli::rule("Done", line = 2, line_col = crayon::green))
}
parseHeader <- function (file) 
{
    line <- 0
    ret <- c("Header.Meta", "Col.Meta", "file.specs") %>% purrr::set_names() %>% 
        purrr::map(~list())
    repeat {
        row_data <- readr::read_lines(file, n_max = 1L, skip = line)
        if (ret$file.specs$EmptyAdat <- length(row_data) == 0) {
            break
        }
        line <- line + 1
        catchRunawayTabs(row_data)
        if (grepl("Checksum", row_data)) {
            ret$Header.Meta$Checksum <- stringr::str_split(row_data, 
                pattern = "\t")[[1L]][2L]
            next
        }
        else if (row_data == "^HEADER") {
            section <- "HEADER"
            next
        }
        else if (row_data == "^COL_DATA") {
            section <- "COL_DATA"
            next
        }
        else if (row_data == "^ROW_DATA") {
            section <- "ROW_DATA"
            next
        }
        else if (row_data == "^TABLE_BEGIN") {
            section <- "Col.Meta"
            ret$file.specs$table.begin <- line
            ret$file.specs$col.meta.start <- line + 1
            next
        }
        else if (grepl("^\\^[A-Z]", row_data)) {
            section <- "Free.Form"
            free_field <- stringr::str_split(row_data, pattern = "\t")[[1L]][1L]
            free_field <- substr(free_field, 2, nchar(free_field))
            next
        }
        tokens <- stringr::str_split(row_data, pattern = "\t")[[1L]]
        if (section == "HEADER" && length(tokens) == 1 && tokens == 
            "") {
            usethis::ui_warn("Blank row(s) detected in `Header` section ... they will be skipped.")
            next
        }
        first_alnum <- stringr::str_which(tokens, "[[:alnum:]]")[1L]
        if (section == "Col.Meta" && first_alnum <= 2) {
            section <- "DATA_TABLE"
        }
        tokens %<>% trim_empty(ifelse(section == "Col.Meta", 
            "left", "right"))
        tokens[1L] <- stringr::str_remove_all(tokens[1L], "^[^A-Za-z]")
        if (section == "HEADER") {
            cur.header <- tokens[1L]
            ret$Header.Meta[[section]][[cur.header]] <- list()
            ret$Header.Meta[[section]][[cur.header]] <- tokens[-1]
        }
        else if (section == "COL_DATA") {
            ret$Header.Meta[[section]][[tokens[1L]]] <- tokens[-1]
        }
        else if (section == "ROW_DATA") {
            ret$Header.Meta[[section]][[tokens[1L]]] <- tokens[-1]
        }
        else if (section == "Free.Form") {
            cur.header <- tokens[1L]
            ret$Header.Meta[[free_field]][[cur.header]] <- list()
            ret$Header.Meta[[free_field]][[cur.header]] <- tokens[-1]
        }
        else if (section == "Col.Meta") {
            ret[[section]][[tokens[1L]]] <- tokens[-1]
            ret$file.specs$col.meta.shift <- first_alnum
        }
        else if (section == "DATA_TABLE") {
            if (diff(range(purrr::map_dbl(ret$Col.Meta, length))) != 
                0) {
                usethis::ui_stop("Col.Meta lengths unequal! The Col.Meta block in not square.\n          There may be trailing tabs in the Col.Meta section.")
            }
            ret$file.specs$data.begin <- line
            ret$row.meta <- tokens
            ret$Header.Meta$TABLE_BEGIN <- basename(file)
            break
        }
    }
    ret$file.specs$old.adat <- getAdatVersion(ret$Header.Meta) < 
        "1.0.0"
    return(ret)
}
prepWriteADAT <- function (data) 
{
    if (missing(data)) {
        usethis::ui_stop("The `data` argument is missing ... \\\n      please pass a `soma_adat` object to `prepWriteADAT()`.")
    }
    ft <- get_features(names(data))
    data <- dplyr::select(data, -all_of(ft), dplyr::everything())
    if (is.intact.attributes(data)) {
        dat_atts <- attributes(data)
    }
    else {
        usethis::ui_oops("Please fix ADAT attributes prior to `write()` call")
        usethis::ui_oops("Calling `is.intact.attributes(data)` should be TRUE")
        usethis::ui_oops("Fix attributes using `SomaPlyr::createChildAttributes()`")
        usethis::ui_code_block("Example:", copy = FALSE)
        usethis::ui_code_block("  data %<>% createChildAttributes(., parent)")
        usethis::ui_stop("Stopping while you fix the attributes of `data`.")
    }
    dat_atts %<>% cleanHeaderMeta()
    dat_atts$Header.Meta$ROW_DATA$Name <- setdiff(names(data), 
        get_features(names(data)))
    dat_atts$Header.Meta$ROW_DATA$Type <- dat_atts$Header.Meta$ROW_DATA$Name %>% 
        purrr::map_chr(~class(data[[.x]])[1L]) %>% dplyr::recode(character = "string", 
        factor = "string", numeric = "double", POSIXct = "double", 
        POSIXt = "double", integer = "integer", integer64 = "integer", 
        logical = "boolean")
    dat_atts$Col.Meta %<>% purrr::modify_if(is.character, ~stringr::str_replace_all(.x, 
        ",", ";"))
    attributes(data) <- dat_atts
    checkADAT(data)
    data
}
syncColMeta <- function (data) 
{
    col_meta <- attributes(data)$Col.Meta
    ft <- get_features(names(data))
    if (all(grepl("^seq[.]", ft))) {
        new_seq <- stringr::str_replace(ft, "^seq[.]", "")
    }
    else {
        matches <- stringr::str_trim(ft) %>% stringr::str_locate(pattern = regexSeqId())
        new_seq <- purrr::pmap_chr(list(string = ft, start = matches[, 
            "start"], end = matches[, "end"]), stringr::str_sub)
    }
    new_seq %<>% stringr::str_replace("\\.", "-")
    k <- match(new_seq, col_meta$SeqId)
    attributes(data)$Col.Meta <- col_meta[k, ]
    data
}
diffVectors <- function (x, y, verbose = getOption("verbose")) 
{
    x_y_diff <- setdiff(x, y)
    y_x_diff <- setdiff(y, x)
    xy_inter <- intersect(x, y)
    xy_union <- union(x, y)
    xname <- deparse(substitute(x))
    yname <- deparse(substitute(y))
    if (verbose) {
        writeLines(cli::rule(crayon::bold("Vectors differ by:"), 
            line_col = crayon::blue))
        c(paste0("Unique to ", xname), paste0("Unique to ", yname), 
            "Common", "Union") %>% format() %>% paste0("  ", 
            cli::symbol$pointer, "  ", purrr::map_int(list(x_y_diff, 
                y_x_diff, xy_inter, xy_union), length)) %>% writeLines()
    }
    ret <- list(x_y_diff, y_x_diff, xy_inter, xy_union)
    names(ret) <- c(paste("unique", c(xname, yname), sep = "_"), 
        "inter", "unique")
    invisible(ret)
}
is.Integer <- function (x) 
{
    if (!is.numeric(x)) {
        return(FALSE)
    }
    all(floor(x) == x, na.rm = TRUE)
}
makeNumeric <- function (x, coerce.factor = TRUE) 
{
    stopifnot(inherits(x, c("data.frame", "tbl_df", "list")))
    safe_num <- purrr::quietly(as.numeric)
    convert_num <- function(.x) {
        y <- safe_num(.x)$warnings
        lgl1 <- !isTRUE(y == "NAs introduced by coercion")
        lgl2 <- ifelse(inherits(.x, "factor"), coerce.factor, 
            TRUE)
        lgl1 && lgl2 && !inherits(.x, "integer")
    }
    purrr::modify_if(x, convert_num, as.numeric)
}
