# Internal functions to SomaDataIO
# Generated by data-raw/create_internals.R
# Do not edit by hand ...

addAttributes <- function(data, new.atts) {
  stopifnot(inherits(new.atts, "list"))
  if ( is.null(dim(data)) ) {
    usethis::ui_warn(
      "Subsetting changed the shape of the object. \\
      Should be a `data.frame` but is class {ui_value(class(data))}."
    )
  }
  attrs <- setdiff(names(new.atts), names(attributes(data)))
  for ( i in attrs ) {
    attributes(data)[[i]] <- new.atts[[i]]
  }
  data
}

addClass <- function(x, class) {
  new_class <- unique(c(class, class(x)))
  structure(x, class = new_class)
}

catchRunawayTabs <- function(x) {
  if ( grepl("^\\^.*[\t]{250,}$", x) ) {
    usethis::ui_oops("Possible runaway tabs!")
    usethis::ui_stop(
      "Invalid ADAT! Empty tabs filling out the entire header block."
    )
  }
  invisible(NULL)
}

cleanNames <- function(x) {
  stringr::str_squish(x) %>%        # zap internal whitespace/leading/trailing
    stringr::str_replace_all("[^A-Za-z0-9_]", ".") %>%  # zap non-alphanum (keep '_')
    stringr::str_replace_all("\\.{2,}", ".") %>% # zap multiple dots
    stringr::str_remove_all("^\\.|\\.$") %>%     # zap leading/trailing dots
    stringr::str_replace_all("^Hyb[.]Scale", "HybControlNormScale") %>%
    stringr::str_replace_all("^Med[.]Scale", "NormScale")
}

convertColMeta <- function(x) {

  # conversion fails if un-equal length columns; we want this as catch
  tbl <- tibble::as_tibble(x) %>%
    rlang::set_names(cleanNames)

  if ( "Dilution" %in% names(tbl) ) {
    tbl <- tbl %>%
      dplyr::mutate(
        Dilution2 = stringr::str_remove_all(Dilution, "%$|Mix ") %>%
          as.numeric() / 100
        )
  }

  # this chunk stolen from SomaPlyr::makeNumeric()
  safe_num    <- purrr::quietly(as.numeric)
  convert_num <- function(.x) {
    y   <- safe_num(.x)$warnings
    lgl <- !isTRUE(y == "NAs introduced by coercion") # warning not tripped?
    lgl && !inherits(.x, c("factor", "integer"))      # don't touch integers/factors
  }

  tbl %>%
    dplyr::mutate_if(convert_num, as.numeric) %>%
    dplyr::mutate(Dilution = as.character(Dilution),    # keep character
                  SeqId    = getSeqId(SeqId, TRUE))     # rm versions; safety
}

genRowNames <- function(adat) {

  checkDups <- function(x) any(duplicated(x))   # internal

  if ( all(c("Subarray", "SlideId") %in% names(adat)) ) {

    adat_rn <- paste0(adat$SlideId, "_", adat$Subarray)

    # Added for datasets with same slide_id sub-scanned with different software
    # nocov start
    if ( checkDups(adat_rn) ) {
      if ( "PlateId" %in% names(adat) ) {
        adat_rn <- paste0(adat$PlateId, "_", adat_rn)
      } else if ( "DatasetId" %in% names(adat) ) {
        adat_rn <- paste0(adat$DatasetId, "_", adat_rn)
      }
      if ( checkDups(adat_rn) ) {
        usethis::ui_warn(
          "Found duplicate row names, i.e. `SlideId_Subarray` non-unique. \\
          They will be numbered sequentially."
        )
        adat_rn <- seq_len(nrow(adat))
      }
    }
    # nocov end
  } else {
    usethis::ui_warn(
      "No SlideId_Subarray found in ADAT. \\
      Rows numbered sequentially."
    )
    adat_rn <- as.character(seq_len(nrow(adat)))
  }
  adat_rn
}

getAdatVersion <- function(x) {

  vidx <- grep("^Version$|^AdatVersion$", names(x$HEADER))

  if ( length(vidx) == 0 ) {
    usethis::ui_stop(
      "Unable to identify ADAT Version from Header information. \\
      Please check 'Header.Meta'."
    )
  }

  version <- x$HEADER[[vidx]]

  if ( length(version) > 1 ) {
    usethis::ui_warn(
      "Version length > 1 ... there may be empty tabs in \\
      the header block filling out the data matrix."
    )
    version <- version[1L]
  }

  if ( version == "1.01" ) {
    # java version catch 1.01: sgf
    usethis::ui_stop(
      "Fix java ADAT writer! Version cannot be `1.01` (set = 1.0.1)"
    )
  }
  version
}

parseCheck <- function(all.tokens, verbose = TRUE) {

  if ( inherits(all.tokens, "character") && length(all.tokens) == 1 ) {
    usethis::ui_stop(
      "Format is wrong for the `all.tokens` argument. \\
      Are you sure you are passing a list of TOKENS and *not* a filename?"
    )
  }

  # ----------------------- #
  # check if necessary pieces
  # of header present
  # ----------------------- #
  firsts     <- purrr::map_chr(all.tokens, head, n = 1)
  chk_string <- c("^HEADER", "^ROW_DATA", "^COL_DATA", "^TABLE_BEGIN")
  if ( any(!chk_string %in% firsts) ) {
    usethis::ui_stop(
      "The following *landmark* tokens is absent from \\
      the ADAT header: {ui_value(setdiff(chk_string, firsts))}",
    )
  }

  # trailing tabs
  tab_test <- all.tokens[[ which(firsts == "^HEADER") ]]
  if ( length(tab_test) > 100 ) {
    # catch for runaway tabs
    writeLines(cli::rule(crayon::bold("Head"), line_col = crayon::blue))
    print(utils::head(tab_test, 10))
    writeLines(cli::rule(crayon::bold("Tail"), line_col = crayon::blue))
    print(utils::tail(tab_test, 10))
    cat("\n")
    usethis::ui_oops(
      "This does not appear to be a valid ADAT
      One possibility is that there are empty tabs filling \\
      out the entire header block.
      Are there empty strings indicated above?")
    cat("\n")
  }

  table_begin          <- which(firsts == "^TABLE_BEGIN")
  which_col_meta_start <- table_begin + 1
  col_meta_shift       <- grep("[A-Za-z0-9]",
                               all.tokens[[ which_col_meta_start ]])[1]

  row_meta <- all.tokens[[ which(firsts == "^ROW_DATA") + 1 ]]
  col_meta <- all.tokens[[ which(firsts == "^COL_DATA") + 1 ]]
  col_meta <- grep(".", col_meta, value = TRUE)[-1]
  row_meta <- grep(".", row_meta, value = TRUE)[-1]

  if ( col_meta_shift != length(row_meta) + 1 ) {
    usethis::ui_stop(
      "The Col.Meta shift {ui_value(col_meta_shift)} does not match the \\
      length stated in ^ROW_DATA row {ui_value(length(row_meta) + 1)} -- \\
      visually inspect ADAT."
    )
  }

  which_col_meta_rows <- seq(which_col_meta_start,
                             which_col_meta_start + length(col_meta) - 1, 1)

  which_header_row <- table_begin + length(col_meta) + 1

  if ( verbose ) {
    writeLines(cli::rule(crayon::bold("Parsing Diagnostics"),
                         line_col = crayon::blue))
    c1 <- list(
      "Table Begin",
      "Col.Meta Start",
      "Col.Meta Shift",
      "Header Row",
      "Rows of the Col Meta") %>% stringr::str_pad(width = 25, "right")
    c2 <- list(
      table_begin,
      which_col_meta_start,
      col_meta_shift,
      which_header_row,
      which_col_meta_rows
    )
    purrr::walk2(c1, c2, ~ usethis::ui_todo("{.x} {ui_value(.y)}"))

    # --- Col Meta --- #
    spaces <- stringr::str_dup(" ", 3)
    writeLines(
      cli::rule(
        crayon::bold("Col Meta"),
        line_col = crayon::blue,
        right = length(col_meta)
      )
    )

    col_print <- col_meta
    L         <- length(col_meta)
    if ( L %% 4 != 0 ) {
      col_print <- c(col_meta, rep("", 4 - L %% 4))
    }

    col_print %<>% format()
    col_print %<>% split(rep(1:4, each = length(.) / 4))
    spaces <- stringr::str_dup(" ", 2)
    paste0(
      spaces,
      col_print[[1L]],
      spaces, crayon::cyan(" | "), spaces,
      col_print[[2L]],
      spaces, crayon::cyan(" | "), spaces,
      col_print[[3L]],
      spaces, crayon::cyan(" | "), spaces,
      col_print[[4L]]
      ) %>%
      writeLines()

    # --- Row Meta --- #
    writeLines(
      cli::rule(
        crayon::bold("Row Meta"),
        line_col = crayon::blue,
        right = length(row_meta)
      )
    )

    row_print <- row_meta
    L         <- length(row_meta)
    if ( L %% 4 != 0 ) {
      row_print %<>% c(rep("", 4 - L %% 4))
    }

    row_print %<>% format()
    row_print %<>% split(rep(1:4, each = length(.) / 4))
    paste0(
      spaces,
      row_print[[1L]],
      spaces, crayon::cyan(" | "), spaces,
      row_print[[2L]],
      spaces, crayon::cyan(" | "), spaces,
      row_print[[3L]],
      spaces, crayon::cyan(" | "), spaces,
      row_print[[4L]]
      ) %>%
      writeLines()
  }


  if ( which_header_row >= length(all.tokens) ) {
    usethis::ui_oops("No feature/RFU data ... Col.Meta only ADAT")
    writeLines(cli::rule("Done", line = 2, line_col = crayon::green))
    return(invisible(NULL))
  }

  # col meta names from Col.Meta block
  # Not from Heater.Meta block
  col_meta2 <- purrr::map_chr(all.tokens[which_col_meta_start:(which_header_row - 1)],
                      function(.x) .x[col_meta_shift])
  # print(col_meta2)   # nolint

  if ( any(duplicated(col_meta2)) ) {
    writeLines(
      cli::rule(
        crayon::bold("Duplicated Col.Meta names"),
        line_col = crayon::blue,
        right = crayon::red("!")
      )
    )
    usethis::ui_oops("Duplicated Col.Meta names in col meta block")
    usethis::ui_oops(
      "Potential over-write scenario for entry: \\
      {ui_value(col_meta2[duplicated(col_meta2))]}"
    )
  }

  # check col meta match
  if ( !setequal(col_meta, col_meta2) ) {
    usethis::ui_oops("Mismatch between `^COL_DATA` in header and `Col.Meta` block:")
    usethis::ui_todo("  In Header:   {ui_value(col_meta)}")
    usethis::ui_todo("  In Col.Meta: {ui_value(col_meta2)}")
    usethis::ui_stop("Stopping check early.")
  }

  # check row meta match
  string_in_table <- stringr::str_subset(all.tokens[[which_header_row]], "[:alnum:]")
  if ( !isTRUE(all.equal(sort(row_meta), sort(string_in_table))) ) {
    cat(
      purrr::walk(1:length(row_meta), function(.x)   # nolint
        sprintf(" %s -- %s\n", row_meta[.x], string_in_table[.x]))
      )
    usethis::ui_stop(
      "Meta data mismatch between `Header Meta` vs `meta data` \\
      in table ... ADAT line: {ui_value(which_header_row)}\n"
    )
  }

  # ------------------------------------------------ #
  # check lengths of each row
  # look for trailing tabs & non-square data block
  # header row can be off by 1 so remove (checked below)
  # ------------------------------------------------ #
  # remove empty header row between feature data and col meta
  token_lengths <- purrr::map_dbl(all.tokens[-which_header_row], length)
  # lengths of data block
  data_lengths <- token_lengths[which_col_meta_start:length(token_lengths)]

  # check if entire data block is of same length
  # if tabs are wrong it won't be
  if ( !all(data_lengths == data_lengths[1]) ) {
    writeLines(
      cli::rule(
        crayon::bold("Possible Tabs Problem"),
        line_col = crayon::blue,
        right = crayon::red("!")
      )
    )
    usethis::ui_todo("All Token lengths:")
    print(token_lengths)
    usethis::ui_todo("Data Block Token lengths:")
    print(data_lengths)
    tab <- table(data_lengths)
    names(dimnames(tab)) <- "Table of Lengths:"
    print(tab)
    usethis::ui_warn(
      "Token length is inconsistent for data matrix block.
      Check for trailing/missing tabs in the main block of the Adat.
      One (or more) of the above is different from the rest."
    )
  }

  # check header row separately
  # compare to first row of feature data
  # do they differ by more than 10?
  # tab error in header row (java issue)
  table_width   <- length(all.tokens[[ which_header_row + 1 ]])
  header_length <- length(all.tokens[[ which_header_row ]])
  if ( (table_width - header_length) > 10 ) {
    writeLines(
      cli::rule(
        crayon::bold("Problem with tabs in Header (blank) row"),
        line_col = crayon::blue,
        right = crayon::red("!")
      )
    )
    usethis::ui_todo("Should be:    {ui_value(table_width)}")
    usethis::ui_todo("Currently is: {ui_value(header_length)}")
    # print(all.tokens[[ which_header_row ]])   # nolint
    usethis::ui_oops("Length of the header row is incorrect")
    usethis::ui_oops("Does not match the width of the data table")
    usethis::ui_oops("Likely a tabs problem ...")
  }

  # check for empty strings
  # in entire Col.Meta block
  # may remove one day; non-essential check
  string_gaps <- !purrr::map_lgl(all.tokens[which_col_meta_rows], function(.x)
                         all(grepl(".", .x[col_meta_shift:length(.x)])))

  if ( any(string_gaps) ) {
    writeLines(
      cli::rule(crayon::bold("Empty Strings Detected in Col.Meta"),
                line_col = crayon::blue,
                right = crayon::red("!"))
    )
    usethis::ui_todo(
      "Visually inspect the following Col.Meta rows: \\
      {ui_value(col_meta2[string_gaps])}"
    )
    usethis::ui_info(
      "  They may be missing in: {ui_value(c('Spuriomers', 'HybControls'))}"
    )
    usethis::ui_todo(
      "Strings may be missing in SOMAmers \\
      without a EntrezGeneSymbol (e.g. a family)"
    )
    usethis::ui_todo("This is a non-critical bug ...")
  }
  cat("\n")
  writeLines(cli::rule("Done", line = 2, line_col = crayon::green))
}

syncColMeta <- function(data) {
  col_meta <- attributes(data)$Col.Meta
  ft       <- getAnalytes(data)

  # if all features have new format
  # no need to use slower regex matching
  if ( all(grepl("^seq[.]", ft)) ) {
    new_seq <- gsub("^seq[.]", "", ft)
  } else {
    matches <- stringr::str_trim(ft) %>%
      stringr::str_locate(pattern = regexSeqId())
    new_seq <- purrr::pmap_chr(
      list(string = ft, start = matches[, "start"], end = matches[, "end"]),
      stringr::str_sub)
  }

  new_seq <- sub("\\.", "-", new_seq)
  k       <- match(new_seq, col_meta$SeqId)
  # Update the attributes -> Col.Meta information
  structure(data, Col.Meta = col_meta[k, ])
}

