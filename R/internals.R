# Internal functions to SomaDataIO
# Generated by data-raw/create_internals.R
# Do not edit by hand ...

addAttributes <- function(data, new.atts) {
  stopifnot(inherits(new.atts, "list"))
  if ( is.null(dim(data)) ) {
    usethis::ui_warn(
      "Subsetting changed the shape of the object. \\
      Should be a `data.frame` but is class {value(class(data))}."
    )
  }
  attrs <- setdiff(names(new.atts), names(attributes(data)))
  for ( i in attrs ) {
    attributes(data)[[i]] <- new.atts[[i]]
  }
  data
}

addClass <- function(x, class) {
  new_class <- unique(c(class, class(x)))
  structure(x, class = new_class)
}

cleanNames <- function(x) {
  squish(x) %>%                          # zap leading/trailing/internal whitespace
    gsub("[^A-Za-z0-9_]", ".", .) %>%    # zap non-alphanum (keep '_')
    gsub("\\.+", ".", .) %>%             # zap multiple dots
    gsub("^\\.|\\.$", "", .) %>%         # zap leading/trailing dots
    sub("^Hyb[.]Scale", "HybControlNormScale", .) %>%
    sub("^Med[.]Scale", "NormScale", .)
}

convertColMeta <- function(x) {

  # conversion fails if un-equal length columns; we want this as catch
  tbl <- tibble::as_tibble(x)
  names(tbl) <- cleanNames(names(tbl))

  if ( !is.null(tbl$Dilution) ) {
    tbl$Dilution2 <- as.numeric(gsub("%$|Mix ", "", tbl$Dilution)) / 100
  }

  convert_num <- function(.x) {
    w <- tryCatch(as.numeric(.x), warning = function(w) w)
    is_warn <- inherits(w, "simpleWarning")
    # NA warning tripped?
    na_warn <- is_warn && identical(w$message, "NAs introduced by coercion")
    num_ok  <- !na_warn
    num_ok && !inherits(.x, c("factor", "integer")) # don't touch factors/integers
  }

  tbl <- purrr::modify_if(tbl, convert_num, as.numeric)
  tbl$Dilution <- as.character(tbl$Dilution)    # keep character
  tbl$SeqId    <- getSeqId(tbl$SeqId, TRUE)     # rm versions; safety
  tbl
}

genRowNames <- function(adat) {

  checkDups <- function(x) any(duplicated(x))   # internal

  if ( all(c("Subarray", "SlideId") %in% names(adat)) ) {

    adat_rn <- paste0(adat$SlideId, "_", adat$Subarray)

    # Added for datasets with same slide_id sub-scanned with different software
    # nocov start
    if ( checkDups(adat_rn) ) {
      if ( "PlateId" %in% names(adat) ) {
        adat_rn <- paste0(adat$PlateId, "_", adat_rn)
      } else if ( "DatasetId" %in% names(adat) ) {
        adat_rn <- paste0(adat$DatasetId, "_", adat_rn)
      }
      if ( checkDups(adat_rn) ) {
        usethis::ui_warn(
          "Found duplicate row names, i.e. `SlideId_Subarray` non-unique. \\
          They will be numbered sequentially."
        )
        adat_rn <- seq_len(nrow(adat))
      }
    }
    # nocov end
  } else {
    usethis::ui_warn(
      "No SlideId_Subarray found in ADAT. \\
      Rows numbered sequentially."
    )
    adat_rn <- as.character(seq_len(nrow(adat)))
  }
  adat_rn
}

getAdatVersion <- function(x) {

  vidx <- grep("^Version$|^AdatVersion$", names(x$HEADER))

  if ( length(vidx) == 0 ) {
    usethis::ui_stop(
      "Unable to identify ADAT Version from Header information. \\
      Please check 'Header.Meta'."
    )
  }

  version <- x$HEADER[[vidx]]

  if ( length(version) > 1 ) {
    usethis::ui_warn(
      "Version length > 1 ... there may be empty tabs in \\
      the header block filling out the data matrix."
    )
    version <- version[1L]
  }

  if ( version == "1.01" ) {
    # java version catch 1.01: sgf
    usethis::ui_stop(
      "Fix java ADAT writer! Version cannot be `1.01` (set = 1.0.1)"
    )
  }
  version
}

parseCheck <- function(all.tokens, verbose = TRUE) {

  if ( inherits(all.tokens, "character") && length(all.tokens) == 1 ) {
    usethis::ui_stop(
      "Format is wrong for the `all.tokens` argument. \\
      Are you sure you are passing a list of TOKENS and *not* a filename?"
    )
  }

  # ----------------------- #
  # check if necessary pieces
  # of header present
  # ----------------------- #
  firsts     <- purrr::map_chr(all.tokens, head, n = 1)
  chk_string <- c("^HEADER", "^ROW_DATA", "^COL_DATA", "^TABLE_BEGIN")
  if ( any(!chk_string %in% firsts) ) {
    usethis::ui_stop(
      "The following *landmark* tokens is absent from \\
      the ADAT header: {value(setdiff(chk_string, firsts))}",
    )
  }

  # trailing tabs
  tab_test <- all.tokens[[ which(firsts == "^HEADER") ]]
  if ( length(tab_test) > 100 ) {
    # catch for runaway tabs
    writeLines(rule(crayon::bold("Head"), line_col = "blue"))
    print(utils::head(tab_test, 10))
    writeLines(rule(crayon::bold("Tail"), line_col = "blue"))
    print(utils::tail(tab_test, 10))
    cat("\n")
    usethis::ui_oops(
      "This does not appear to be a valid ADAT
      One possibility is that there are empty tabs filling \\
      out the entire header block.
      Are there empty strings indicated above?")
    cat("\n")
  }

  table_begin          <- which(firsts == "^TABLE_BEGIN")
  which_col_meta_start <- table_begin + 1
  col_meta_shift       <- grep("[A-Za-z0-9]",
                               all.tokens[[ which_col_meta_start ]])[1]

  row_meta <- all.tokens[[ which(firsts == "^ROW_DATA") + 1 ]]
  col_meta <- all.tokens[[ which(firsts == "^COL_DATA") + 1 ]]
  col_meta <- grep(".", col_meta, value = TRUE)[-1]
  row_meta <- grep(".", row_meta, value = TRUE)[-1]

  if ( col_meta_shift != length(row_meta) + 1 ) {
    usethis::ui_stop(
      "The Col.Meta shift {value(col_meta_shift)} does not match the \\
      length stated in ^ROW_DATA row {value(length(row_meta) + 1)} -- \\
      visually inspect ADAT."
    )
  }

  which_col_meta_rows <- seq(which_col_meta_start,
                             which_col_meta_start + length(col_meta) - 1, 1)

  which_header_row <- table_begin + length(col_meta) + 1

  if ( verbose ) {
    writeLines(rule(crayon::bold("Parsing Diagnostics"), line_col = "blue"))
    c1 <- c(
      "Table Begin",
      "Col.Meta Start",
      "Col.Meta Shift",
      "Header Row",
      "Rows of the Col Meta") %>% .pad(25)
    c2 <- list(
      table_begin,
      which_col_meta_start,
      col_meta_shift,
      which_header_row,
      which_col_meta_rows
    )
    purrr::walk2(c1, c2, ~ usethis::ui_todo("{.x} {value(.y)}"))

    # --- Col Meta --- #
    spaces <- strrep(" ", 3)
    writeLines(
      rule(
        crayon::bold("Col Meta"), line_col = "blue", right = length(col_meta)
      )
    )

    col_print <- col_meta
    L         <- length(col_meta)
    if ( L %% 4 != 0 ) {
      col_print <- c(col_meta, rep("", 4 - L %% 4))
    }

    col_print %<>% format()
    col_print %<>% split(rep(1:4, each = length(.) / 4))
    spaces <- strrep(" ", 2)
    paste0(
      spaces,
      col_print[[1L]],
      spaces, crayon::cyan(" | "), spaces,
      col_print[[2L]],
      spaces, crayon::cyan(" | "), spaces,
      col_print[[3L]],
      spaces, crayon::cyan(" | "), spaces,
      col_print[[4L]]
      ) %>%
      writeLines()

    # --- Row Meta --- #
    writeLines(
      rule(
        crayon::bold("Row Meta"), line_col = "blue", right = length(row_meta)
      )
    )

    row_print <- row_meta
    L         <- length(row_meta)
    if ( L %% 4 != 0 ) {
      row_print %<>% c(rep("", 4 - L %% 4))
    }

    row_print %<>% format()
    row_print %<>% split(rep(1:4, each = length(.) / 4))
    paste0(
      spaces,
      row_print[[1L]],
      spaces, crayon::cyan(" | "), spaces,
      row_print[[2L]],
      spaces, crayon::cyan(" | "), spaces,
      row_print[[3L]],
      spaces, crayon::cyan(" | "), spaces,
      row_print[[4L]]
      ) %>%
      writeLines()
  }


  if ( which_header_row >= length(all.tokens) ) {
    usethis::ui_oops("No feature/RFU data ... Col.Meta only ADAT")
    writeLines(rule("Done", line = 2, line_col = "green"))
    return(invisible(NULL))
  }

  # col meta names from Col.Meta block
  # Not from Heater.Meta block
  col_meta2 <- purrr::map_chr(all.tokens[which_col_meta_start:(which_header_row - 1)],
                      function(.x) .x[col_meta_shift])
  # print(col_meta2)   # nolint

  if ( any(duplicated(col_meta2)) ) {
    writeLines(
      rule(
        crayon::bold("Duplicated Col.Meta names"),
        line_col = "blue", right = crayon::red("!")
      )
    )
    usethis::ui_oops("Duplicated Col.Meta names in col meta block")
    usethis::ui_oops(
      "Potential over-write scenario for entry: \\
      {value(col_meta2[duplicated(col_meta2))]}"
    )
  }

  # check col meta match
  if ( !setequal(col_meta, col_meta2) ) {
    usethis::ui_oops("Mismatch between `^COL_DATA` in header and `Col.Meta` block:")
    usethis::ui_todo("  In Header:   {value(col_meta)}")
    usethis::ui_todo("  In Col.Meta: {value(col_meta2)}")
    usethis::ui_stop("Stopping check early.")
  }

  # check row meta match
  string_in_table <- grep("[[:alnum:]]", all.tokens[[which_header_row]],
                          value = TRUE)
  if ( !isTRUE(all.equal(sort(row_meta), sort(string_in_table))) ) {
    cat(
      purrr::walk(1:length(row_meta), function(.x)   # nolint
        sprintf(" %s -- %s\n", row_meta[.x], string_in_table[.x]))
      )
    usethis::ui_stop(
      "Meta data mismatch between `Header Meta` vs `meta data` \\
      in table ... ADAT line: {value(which_header_row)}\n"
    )
  }

  # ------------------------------------------------ #
  # check lengths of each row
  # look for trailing tabs & non-square data block
  # header row can be off by 1 so remove (checked below)
  # ------------------------------------------------ #
  # remove empty header row between feature data and col meta
  token_lengths <- purrr::map_dbl(all.tokens[-which_header_row], length)
  # lengths of data block
  data_lengths <- token_lengths[which_col_meta_start:length(token_lengths)]

  # check if entire data block is of same length
  # if tabs are wrong it won't be
  if ( !all(data_lengths == data_lengths[1]) ) {
    writeLines(
      rule(
        crayon::bold("Possible Tabs Problem"),
        line_col = "blue", right = crayon::red("!")
      )
    )
    usethis::ui_todo("All Token lengths:")
    print(token_lengths)
    usethis::ui_todo("Data Block Token lengths:")
    print(data_lengths)
    tab <- table(data_lengths)
    names(dimnames(tab)) <- "Table of Lengths:"
    print(tab)
    usethis::ui_warn(
      "Token length is inconsistent for data matrix block.
      Check for trailing/missing tabs in the main block of the Adat.
      One (or more) of the above is different from the rest."
    )
  }

  # check header row separately
  # compare to first row of feature data
  # do they differ by more than 10?
  # tab error in header row (java issue)
  table_width   <- length(all.tokens[[ which_header_row + 1 ]])
  header_length <- length(all.tokens[[ which_header_row ]])
  if ( (table_width - header_length) > 10 ) {
    writeLines(
      rule(
        crayon::bold("Problem with tabs in Header (blank) row"),
        line_col = "blue", right = crayon::red("!")
      )
    )
    usethis::ui_todo("Should be:    {value(table_width)}")
    usethis::ui_todo("Currently is: {value(header_length)}")
    # print(all.tokens[[ which_header_row ]])   # nolint
    usethis::ui_oops("Length of the header row is incorrect")
    usethis::ui_oops("Does not match the width of the data table")
    usethis::ui_oops("Likely a tabs problem ...")
  }

  # check for empty strings
  # in entire Col.Meta block
  # may remove one day; non-essential check
  string_gaps <- !purrr::map_lgl(all.tokens[which_col_meta_rows], function(.x)
                         all(grepl(".", .x[col_meta_shift:length(.x)])))

  if ( any(string_gaps) ) {
    writeLines(
      rule(
        crayon::bold("Empty Strings Detected in Col.Meta"),
        line_col = "blue", right = crayon::red("!"))
    )
    usethis::ui_todo(
      "Visually inspect the following Col.Meta rows: \\
      {value(col_meta2[string_gaps])}"
    )
    usethis::ui_info(
      "  They may be missing in: {value(c('Spuriomers', 'HybControls'))}"
    )
    usethis::ui_todo(
      "Strings may be missing in SOMAmers \\
      without a EntrezGeneSymbol (e.g. a family)"
    )
    usethis::ui_todo("This is a non-critical bug ...")
  }
  writeLines(rule("Parse Diagnostic Complete", line = 2, line_col = "green"))
}

syncColMeta <- function(data) {
  col_meta <- attr(data, "Col.Meta")
  # no trim leading whitespace if 'else' below is to perform pattern match
  ft <- trimws(getAnalytes(data), which = "right")
  # if all features have new format; no need to match (speed)
  if ( all(grepl("^seq[.]", ft)) ) {
    new_seq <- gsub("^seq[.]", "", ft)
  } else {
    df <- locateSeqId(ft)
    new_seq <- substr(df$x, df$start, df$stop)
  }
  new_seq <- sub("\\.", "-", new_seq)
  k       <- match(new_seq, col_meta$SeqId)
  # Update the attributes -> Col.Meta information
  structure(data, Col.Meta = col_meta[k, ])
}

